<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trình phát video với phụ đề, dịch và lặp đoạn</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .video-container {
      position: relative;
      width: 95%;
      margin: 0 auto;
    }
    #video-player {
      width: 100%;
      height: auto;
      display: block;
    }
    #subtitles {
      position: absolute;
      bottom: 15%;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      padding: 10px;
      pointer-events: auto;
      z-index: 2147483647;
      display: block;
      visibility: visible;
      white-space: pre-wrap;
      line-height: 1.2;
      transform: translateZ(0);
      contain: paint;
    }
    .subtitle {
      cursor: pointer;
      display: inline;
      margin: 0 0.05em;
      padding: 2px 3px;
      letter-spacing: -0.02em;
      transition: color 0.2s;
    }
    .subtitle:hover {
      color: orange;
    }
    .selected {
      color: yellow;
      font-weight: bold;
    }
    #error-message {
      color: red;
      display: none;
      margin-bottom: 1rem;
      text-align: center;
    }
    #translation-popup {
      display: none;
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      z-index: 2147483648;
      max-width: 400px;
      font-size: 0.9rem;
      cursor: move;
      user-select: none;
    }
    #translation-popup .close-btn {
      position: absolute;
      top: 5px;
      right: 10px;
      cursor: pointer;
      font-size: 1.2rem;
    }
    .input-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 1rem;
      z-index: 2147483646;
    }
    .input-box {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      width: 80%;
      max-width: 400px;
    }
    .custom-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #f1f1f1;
      padding: 5px;
      border-radius: 0 0 8px 8px;
      width: 95%;
      margin: 0 auto;
      flex-wrap: wrap;
    }
    .custom-controls button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }
    .custom-controls button:hover {
      background: #45a049;
    }
    #clear-data {
      background: #f44336;
    }
    #clear-data:hover {
      background: #da190b;
    }
    .custom-controls span {
      font-size: 12px;
      color: #333;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 24px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #ccc;
      transition: 0.4s;
      border-radius: 24px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      color: white;
      font-size: 10px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: white;
      transition: 0.4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background: #4CAF50;
    }
    input:checked + .slider:before {
      transform: translateX(36px);
    }
    .toggle-text {
      margin-left: 5px;
    }
    .loop-list-container {
      margin-top: 1rem;
      background: white;
      padding: 1rem;
      border-radius: 8px;
      width: 95%;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    #loop-list {
      list-style: none;
      padding: 0;
      max-height: 150px;
      overflow-y: auto;
    }
    #loop-list li {
      padding: 0.5rem;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #loop-list li:hover {
      background-color: #f0f0f0;
    }
    .delete-loop {
      color: red;
      cursor: pointer;
    }
    #loop-markers {
      position: relative;
      height: 2rem;
      width: 100%;
      margin-top: -10px;
      z-index: 100;
    }
    .loop-marker {
      position: absolute;
      width: 24px;
      height: 24px;
      background: #4CAF50;
      color: white;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      line-height: 24px;
      transform: translateX(-50%);
    }
    .loop-marker:nth-child(odd) {
      top: -25px;
    }
    .loop-marker:nth-child(even) {
      bottom: -25px;
    }
  </style>
</head>
<body class="bg-gray-100 font-sans">
  <div class="container mx-auto p-4">
    <div id="error-message" class="mb-4"></div>
    <div class="video-container">
      <video id="video-player" controls></video>
      <div class="custom-controls">
        <button id="set-loop-start" title="Đặt thời điểm bắt đầu đoạn lặp">Bắt đầu</button>
        <span id="loop-start-display">00:00</span>
        <button id="set-loop-end" title="Đặt thời điểm kết thúc đoạn lặp">Kết thúc</button>
        <span id="loop-end-display">00:00</span>
        <button id="add-loop" title="Thêm đoạn lặp vào danh sách">Thêm</button>
        <label class="toggle-switch">
          <input type="checkbox" id="toggle-loop">
          <span class="slider" title="Bật/tắt chức năng lặp đoạn">Lặp: <span class="toggle-text">TẮT</span></span>
        </label>
        <label class="toggle-switch">
          <input type="checkbox" id="toggle-subtitles" checked>
          <span class="slider" title="Bật/tắt hiển thị phụ đề">Phụ đề: <span class="toggle-text">BẬT</span></span>
        </label>
        <button id="clear-data" title="Xóa video, phụ đề và danh sách đoạn lặp">Xóa</button>
      </div>
      <div id="loop-markers"></div>
      <div id="subtitles"></div>
      <div id="input-overlay" class="input-overlay">
        <div class="input-box">
          <label class="block mb-2 font-bold text-gray-700">Nhập URL video hoặc tải file video:</label>
          <input type="text" id="video-url" placeholder="Nhập URL video (ví dụ: https://example.com/video.mp4)" class="border p-2 w-full mb-2">
          <input type="file" id="video-upload" accept="video/*" class="border p-2 w-full">
        </div>
        <div class="input-box">
          <label class="block mb-2 font-bold text-gray-700">Tải file phụ đề (.srt):</label>
          <input type="file" id="subtitle-upload" accept=".srt" class="border p-2 w-full">
        </div>
      </div>
      <div id="translation-popup">
        <span class="close-btn" onclick="closePopup()">×</span>
        <div id="popup-content"></div>
      </div>
    </div>
      <div class="subtitle-box mt-2 bg-white p-4 rounded-lg shadow-md w-full mx-auto">
        <label class="block mb-2 font-bold text-gray-700">Phụ đề (bôi đen để dịch):</label>
        <textarea id="subtitle-display" class="w-full h-24 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-center" readonly placeholder="Phụ đề sẽ được hiển thị tại đây..."></textarea>
      </div>
    <div class="loop-list-container">
      <h4 class="font-bold">Danh sách đoạn lặp</h4>
      <ul id="loop-list"></ul>
    </div>
  </div>

  <script>
    const video = document.getElementById('video-player');
    const videoContainer = document.querySelector('.video-container');
    const inputOverlay = document.getElementById('input-overlay');
    const videoUrlInput = document.getElementById('video-url');
    const videoUpload = document.getElementById('video-upload');
    const subtitleUpload = document.getElementById('subtitle-upload');
    const subtitlesDiv = document.getElementById('subtitles');
    const subtitleDisplay = document.getElementById('subtitle-display');
    const translationPopup = document.getElementById('translation-popup');
    const popupContent = document.getElementById('popup-content');
    const errorMessage = document.getElementById('error-message');
    const setLoopStartElement = document.getElementById('set-loop-start');
    const setLoopEndElement = document.getElementById('set-loop-end');
    const loopStartElement = document.getElementById('loop-start-display');
    const loopEndElement = document.getElementById('loop-end-display');
    const addLoopElement = document.getElementById('add-loop');
    const toggleLoopElement = document.getElementById('toggle-loop');
    const toggleSubtitlesElement = document.getElementById('toggle-subtitles');
    const clearDataElement = document.getElementById('clear-data');
    const loopListElement = document.getElementById('loop-list');
    const loopMarkersElement = document.getElementById('loop-markers');
    let subtitles = [];
    let currentSentence = '';
    let isVideoLoaded = false;
    let isSubtitlesLoaded = false;
    let hasPlayed = false;
    let isLooping = false;
    let subtitleEnabled = true;
    let loopStart = 0;
    let loopEnd = 0;
    let loops = [];
    const debounceDelay = 100;

    // API keys
    const apiKeys = [
      'AIzaSyDtnZx4SDYq44Zf61YOJpgtxZT8eOwho9I', // Thay bằng key Gemini API hợp lệ
      'AIzaSyC9XqHlD3FLn1bffhbKBXRKwHh6Xdbriy4', // Thay bằng key Gemini API hợp lệ
    ];
    let currentApiKeyIndex = 0;

    // Format time to MM:SS
    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Load from localStorage
    function loadFromLocalStorage() {
      const videoUrl = localStorage.getItem('videoUrl');
      const videoFileName = localStorage.getItem('videoFileName');
      const srtContent = localStorage.getItem('subtitleContent');
      const loopList = localStorage.getItem('loopList');
      const loopEnabled = localStorage.getItem('loopEnabled');
      const subtitleEnabledStored = localStorage.getItem('subtitleEnabled');

      if (videoUrl) {
        try {
          video.src = videoUrl;
          video.load();
          isVideoLoaded = true;
          console.log('Đã tải video từ URL:', videoUrl);
          video.addEventListener('loadedmetadata', tryPlayVideo, { once: true });
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `Không thể tải video từ bộ nhớ: ${error.message}`;
          console.error('Lỗi tải video từ URL:', error);
          isVideoLoaded = false;
        }
      } else if (videoFileName) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = `Vui lòng tải lại file video: ${videoFileName}`;
        console.log('Phát hiện file video cục bộ, yêu cầu tải lại:', videoFileName);
        isVideoLoaded = false;
      }

      if (srtContent) {
        try {
          subtitles = parseSRT(srtContent);
          isSubtitlesLoaded = subtitles.length > 0;
          displaySubtitles();
          console.log('Đã tải phụ đề từ bộ nhớ:', subtitles.length, 'khối');
          if (!isSubtitlesLoaded) {
            errorMessage.style.display = 'block';
            errorMessage.textContent = 'Không tìm thấy phụ đề hợp lệ trong bộ nhớ. Vui lòng tải lại file SRT.';
            console.warn('Không phân tích được phụ đề hợp lệ từ bộ nhớ.');
          } else {
            tryPlayVideo();
          }
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `Lỗi khi khôi phục phụ đề: ${error.message}. Vui lòng tải lại file SRT.`;
          console.error('Lỗi tải phụ đề:', error);
          isSubtitlesLoaded = false;
        }
      }

      if (loopList) {
        try {
          loops = JSON.parse(loopList);
          updateLoopList();
          console.log('Đã tải danh sách đoạn lặp:', loops);
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `Không thể tải danh sách đoạn lặp: ${error.message}`;
          console.error('Lỗi tải danh sách đoạn lặp:', error);
        }
      }

      isLooping = loopEnabled !== null ? JSON.parse(loopEnabled) : false;
      toggleLoopElement.checked = isLooping;
      toggleLoopElement.nextElementSibling.querySelector('.toggle-text').textContent = isLooping ? 'BẬT' : 'TẮT';
      console.log('Trạng thái lặp:', isLooping);

      subtitleEnabled = subtitleEnabledStored !== null ? JSON.parse(subtitleEnabledStored) : true;
      toggleSubtitlesElement.checked = subtitleEnabled;
      toggleSubtitlesElement.nextElementSibling.querySelector('.toggle-text').textContent = subtitleEnabled ? 'BẬT' : 'TẮT';
      subtitlesDiv.style.display = subtitleEnabled ? 'block' : 'none';
      console.log('Trạng thái phụ đề:', subtitleEnabled);

      if (isSubtitlesLoaded && subtitleEnabled) {
        updateSubtitles();
      }
    }

    // Parse SRT file content
    function parseSRT(data) {
      try {
        let normalizedData = data.replace(/\uFEFF/g, '').replace(/\r\n|\r|\n/g, '\n').trim();
        const blocks = normalizedData.split(/\n\n+/).filter(block => block.trim());
        if (!blocks.length) {
          throw new Error('File SRT trống hoặc không chứa khối hợp lệ.');
        }
        const parsedSubtitles = [];
        blocks.forEach((block, index) => {
          try {
            const lines = block.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
              console.warn(`Khối ${index + 1} bị bỏ qua: Không đủ dòng.`);
              return;
            }
            let timeLineIndex = lines.findIndex(line => line.includes(' --> '));
            if (timeLineIndex === -1) {
              console.warn(`Khối ${index + 1} bị bỏ qua: Không tìm thấy dòng thời gian.`);
              return;
            }
            if (timeLineIndex > 0 && /^\d+$/.test(lines[0])) {
              lines.splice(0, 1);
              timeLineIndex--;
            }
            const timeLine = lines[timeLineIndex];
            const contentLines = lines.slice(timeLineIndex + 1).filter(line => line.trim());
            if (!contentLines.length) {
              console.warn(`Khối ${index + 1} bị bỏ qua: Không có nội dung phụ đề.`);
              return;
            }
            const [start, end] = timeLine.split(' --> ').map(t => {
              const timeStr = t.replace(',', '.').trim();
              const [h, m, s] = timeStr.split(':');
              if (isNaN(h) || isNaN(m) || isNaN(s)) {
                throw new Error(`Định dạng thời gian không hợp lệ: ${t}`);
              }
              return parseInt(h) * 3600 + parseInt(m) * 60 + parseFloat(s);
            });
            if (start >= end) {
              console.warn(`Khối ${index + 1} bị bỏ qua: Thời gian bắt đầu (${start}) >= kết thúc (${end}).`);
              return;
            }
            parsedSubtitles.push({ startTime: start, endTime: end, contentLines });
          } catch (blockError) {
            console.error(`Lỗi ở khối ${index + 1}: ${blockError.message}`);
          }
        });
        if (!parsedSubtitles.length) {
          throw new Error('Không tìm thấy khối phụ đề hợp lệ nào trong file.');
        }
        console.log(`Đã phân tích thành công ${parsedSubtitles.length} khối phụ đề.`);
        return parsedSubtitles;
      } catch (error) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = `Lỗi phân tích file SRT: ${error.message}. Vui lòng kiểm tra định dạng SRT và mã hóa UTF-8.`;
        console.error('Lỗi phân tích SRT:', error);
        return [];
      }
    }

    // Update loop markers
    function updateLoopMarkers() {
      loopMarkersElement.innerHTML = '';
      loops.forEach((loop, index) => {
        const marker = document.createElement('div');
        marker.className = 'loop-marker';
        marker.textContent = index + 1;
        const positionPercent = (loop.start / video.duration) * 100;
        marker.style.left = `${positionPercent}%`;
        marker.addEventListener('click', () => {
          video.currentTime = loop.start;
          video.play();
          if (isLooping) {
            loopStart = loop.start;
            loopEnd = loop.end;
            loopStartElement.textContent = formatTime(loopStart);
            loopEndElement.textContent = formatTime(loopEnd);
          }
        });
        loopMarkersElement.appendChild(marker);
      });
    }

    // Update loop list
    function updateLoopList() {
      loopListElement.innerHTML = '';
      loops.forEach((loop, index) => {
        const li = document.createElement('li');
        li.innerHTML = `${formatTime(loop.start)} → ${formatTime(loop.end)} <span class="delete-loop">Xóa</span>`;
        li.addEventListener('click', (e) => {
          if (e.target.classList.contains('delete-loop')) {
            loops.splice(index, 1);
            updateLoopList();
            localStorage.setItem('loopList', JSON.stringify(loops));
            updateLoopMarkers();
            return;
          }
          video.currentTime = loop.start;
          video.play();
          if (isLooping) {
            loopStart = loop.start;
            loopEnd = loop.end;
            loopStartElement.textContent = formatTime(loopStart);
            loopEndElement.textContent = formatTime(loopEnd);
          }
        });
        loopListElement.appendChild(li);
      });
      updateLoopMarkers();
      localStorage.setItem('loopList', JSON.stringify(loops));
    }

    // Update subtitles
    function updateSubtitles() {
      if (!subtitleEnabled) {
        subtitlesDiv.style.display = 'none';
        subtitleDisplay.value = '';
        return;
      }
      const isFullscreen = !!document.fullscreenElement;
      const videoRect = video.getBoundingClientRect();
      const videoHeight = videoRect.height;
      const windowHeight = window.innerHeight;
      const fontSizePx = isFullscreen ? windowHeight * 0.06 : videoHeight * 0.06;

      subtitlesDiv.style.position = 'absolute';
      subtitlesDiv.style.bottom = '15%';
      subtitlesDiv.style.left = '0';
      subtitlesDiv.style.right = '0';
      subtitlesDiv.style.width = `${videoRect.width}px`;
      subtitlesDiv.style.zIndex = '2147483647';
      subtitlesDiv.style.fontSize = `${fontSizePx}px`;
      subtitlesDiv.style.textShadow = `2px 2px 4px rgba(0, 0, 0, 0.8)`;
      subtitlesDiv.style.display = 'block';
      subtitlesDiv.style.willChange = 'transform, opacity';

      const currentTime = video.currentTime;
      const currentSubtitle = subtitles.find(sub => sub.startTime <= currentTime && currentTime <= sub.endTime);
      subtitleDisplay.value = currentSubtitle ? currentSubtitle.contentLines.join('\n') : '';

      requestAnimationFrame(() => {
        setTimeout(() => {
          subtitlesDiv.style.visibility = 'visible';
          subtitlesDiv.style.willChange = 'auto';
        }, 0);
      });
    }

    // Initialize subtitle display
    function displaySubtitles() {
      subtitlesDiv.innerHTML = subtitles.length ? '' : 'Chưa tải phụ đề. Vui lòng tải file SRT hợp lệ.';
      subtitleDisplay.value = subtitles.length ? '' : 'Chưa tải phụ đề. Vui lòng tải file SRT hợp lệ.';
      errorMessage.style.display = 'none';
      updateSubtitles();
    }

    // Try to play video
    function tryPlayVideo() {
      if (isVideoLoaded && !hasPlayed) {
        video.muted = true; // Tạm thời tắt âm thanh để vượt qua hạn chế tự động phát
        inputOverlay.style.display = 'none';
        video.play().then(() => {
          hasPlayed = true;
          video.muted = false; // Bật lại âm thanh sau khi phát thành công
          console.log('Video đã bắt đầu phát.');
          if (isSubtitlesLoaded && subtitleEnabled) {
            updateSubtitles();
          }
        }).catch(e => {
          video.muted = false;
          errorMessage.style.display = 'block';
          errorMessage.textContent = `Không thể phát video: ${e.message}. Vui lòng nhấn phát thủ công.`;
          inputOverlay.style.display = 'flex';
          console.error('Lỗi phát video:', e);
        });
      }
    }

    // Load video from URL
    videoUrlInput.addEventListener('change', () => {
      const url = videoUrlInput.value.trim();
      if (url) {
        try {
          video.src = url;
          video.load();
          isVideoLoaded = true;
          localStorage.setItem('videoUrl', url);
          localStorage.removeItem('videoFileName');
          errorMessage.style.display = 'none';
          console.log('Đã tải video từ URL:', url);
          video.addEventListener('loadedmetadata', tryPlayVideo, { once: true });
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `Không thể tải video từ URL: ${error.message}`;
          console.error('Lỗi tải video từ URL:', error);
          isVideoLoaded = false;
          localStorage.removeItem('videoUrl');
        }
      }
    });

    // Load video from file
    videoUpload.addEventListener('change', (e) => {
      const videoFile = e.target.files[0];
      if (videoFile) {
        try {
          const fileUrl = URL.createObjectURL(videoFile);
          video.src = fileUrl;
          video.load();
          isVideoLoaded = true;
          localStorage.setItem('videoFileName', videoFile.name);
          localStorage.removeItem('videoUrl');
          errorMessage.style.display = 'none';
          console.log('Đã tải file video cục bộ:', videoFile.name);
          video.addEventListener('loadedmetadata', tryPlayVideo, { once: true });
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `Không thể tải file video: ${error.message}`;
          console.error('Lỗi tải file video:', error);
          isVideoLoaded = false;
          localStorage.removeItem('videoFileName');
        }
      }
    });

    // Load and display subtitles
    subtitleUpload.addEventListener('change', (e) => {
      const subtitleFile = e.target.files[0];
      if (!subtitleFile) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Vui lòng chọn file SRT.';
        console.error('Chưa chọn file SRT.');
        return;
      }
      if (!subtitleFile.name.toLowerCase().endsWith('.srt')) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Vui lòng tải file .srt hợp lệ.';
        console.error('Định dạng file không hợp lệ:', subtitleFile.name);
        return;
      }
      const fileReader = new FileReader();
      fileReader.onload = (event) => {
        try {
          const subtitleText = event.target.result;
          console.log('Đã tải file SRT, kích thước:', subtitleText.length, 'ký tự');
          subtitles = parseSRT(subtitleText);
          isSubtitlesLoaded = subtitles.length > 0;
          localStorage.setItem('subtitleContent', subtitleText);
          displaySubtitles();
          if (subtitles.length === 0) {
            errorMessage.style.display = 'block';
            errorMessage.textContent = 'Không tìm thấy phụ đề hợp lệ trong file SRT. Vui lòng kiểm tra định dạng và mã hóa UTF-8.';
            console.warn('Không phân tích được phụ đề hợp lệ.');
          } else {
            errorMessage.style.display = 'none';
            console.log('Đã tải phụ đề thành công:', subtitles);
            tryPlayVideo();
          }
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `Lỗi khi đọc file SRT: ${error.message}`;
          console.error('Lỗi đọc file SRT:', error);
          isSubtitlesLoaded = false;
        }
      };
      fileReader.onerror = () => {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Không thể đọc file SRT. Vui lòng thử lại.';
        console.error('Lỗi FileReader với file SRT.');
        isSubtitlesLoaded = false;
      };
      fileReader.readAsText(subtitleFile, 'UTF-8');
    });

    // Handle subtitle word click
    subtitlesDiv.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      e.preventDefault();
      const subtitleTarget = e.target.closest('.subtitle');
      if (!subtitleTarget) return;
      document.querySelectorAll('.subtitle').forEach(w => w.classList.remove('selected'));
      subtitleTarget.classList.add('selected');
      video.pause();
      translateWord(subtitleTarget.textContent, subtitleTarget);
    });

    // Handle subtitle selection in textarea
    subtitleDisplay.addEventListener('mouseup', () => {
      const selectedText = subtitleDisplay.value.substring(subtitleDisplay.selectionStart, subtitleDisplay.selectionEnd).trim();
      if (selectedText) {
        video.pause();
        translateWord(selectedText, subtitleDisplay);
      }
    });

    // Debounce function
    function debounce(func, delay) {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func(...args), delay);
      };
    }

    // Update subtitles on timeupdate
    video.addEventListener('timeupdate', debounce(() => {
      if (video.paused) return;
      handleLooping();
      const currentTime = video.currentTime;
      const currentSubtitle = subtitles.find(sub => sub.startTime <= currentTime && currentTime <= sub.endTime);
      currentSentence = currentSubtitle ? currentSubtitle.contentLines.join(' ') : '';
      const newSubtitleText = currentSubtitle ? currentSubtitle.contentLines.join('<br>') : '';
      subtitlesDiv.innerHTML = newSubtitleText;
      makeWordsSelectable();
      updateSubtitles();
    }, debounceDelay));

    // Make subtitle words selectable
    function makeWordsSelectable() {
      const subtitleText = subtitlesDiv.innerHTML;
      if (subtitleText) {
        const subtitleLines = subtitleText.split('<br>').map(line => {
          const words = line.split(' ').map(word => `<span class="subtitle">${word}</span>`).join(' ');
          return words;
        });
        subtitlesDiv.innerHTML = subtitleLines.join('<br>');
      }
    }

    // Handle looping
    function handleLooping() {
      if (isLooping && video.currentTime >= loopEnd) {
        video.currentTime = loopStart;
        video.play();
      }
    }

    // Set loop start
    setLoopStartElement.addEventListener('click', () => {
      loopStart = video.currentTime;
      loopStartElement.textContent = formatTime(loopStart);
    });

    // Set loop end
    setLoopEndElement.addEventListener('click', () => {
      loopEnd = video.currentTime;
      loopEndElement.textContent = formatTime(loopEnd);
    });

    // Add loop
    addLoopElement.addEventListener('click', () => {
      if (loopStart >= loopEnd || loopStart < 0 || loopEnd > video.duration) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Thời gian lặp không hợp lệ. Vui lòng đảm bảo thời gian bắt đầu nhỏ hơn thời gian kết thúc và nằm trong phạm vi video.';
        return;
      }
      loops.push({ start: loopStart, end: loopEnd });
      updateLoopList();
      loopStart = 0;
      loopEnd = 0;
      loopStartElement.textContent = '00:00';
      loopEndElement.textContent = '00:00';
      errorMessage.style.display = 'none';
    });

    // Toggle loop
    toggleLoopElement.addEventListener('change', () => {
      isLooping = toggleLoopElement.checked;
      toggleLoopElement.nextElementSibling.querySelector('.toggle-text').textContent = isLooping ? 'BẬT' : 'TẮT';
      localStorage.setItem('loopEnabled', isLooping);
      if (!isLooping) {
        loopStart = 0;
        loopEnd = video.duration || 0;
        loopStartElement.textContent = '00:00';
        loopEndElement.textContent = formatTime(loopEnd);
      }
      console.log('Đã thay đổi trạng thái lặp:', isLooping);
    });

    // Toggle subtitles
    toggleSubtitlesElement.addEventListener('change', () => {
      subtitleEnabled = toggleSubtitlesElement.checked;
      subtitlesDiv.style.display = subtitleEnabled ? 'block' : 'none';
      subtitleDisplay.value = subtitleEnabled ? subtitleDisplay.value : '';
      toggleSubtitlesElement.nextElementSibling.querySelector('.toggle-text').textContent = subtitleEnabled ? 'BẬT' : 'TẮT';
      localStorage.setItem('subtitleEnabled', subtitleEnabled);
      if (subtitleEnabled) updateSubtitles();
      console.log('Đã thay đổi trạng thái phụ đề:', subtitleEnabled);
    });

    // Clear data
    clearDataElement.addEventListener('click', () => {
      localStorage.removeItem('videoUrl');
      localStorage.removeItem('videoFileName');
      localStorage.removeItem('subtitleContent');
      localStorage.removeItem('loopList');
      localStorage.removeItem('loopEnabled');
      localStorage.removeItem('subtitleEnabled');
      video.src = '';
      video.load();
      subtitles = [];
      loops = [];
      isVideoLoaded = false;
      isSubtitlesLoaded = false;
      hasPlayed = false;
      isLooping = false;
      subtitleEnabled = true;
      inputOverlay.style.display = 'flex';
      subtitlesDiv.innerHTML = '';
      subtitlesDiv.style.display = 'none';
      subtitleDisplay.value = '';
      loopListElement.innerHTML = '';
      loopMarkersElement.innerHTML = '';
      loopStartElement.textContent = '00:00';
      loopEndElement.textContent = '00:00';
      toggleLoopElement.checked = false;
      toggleLoopElement.nextElementSibling.querySelector('.toggle-text').textContent = 'TẮT';
      toggleSubtitlesElement.checked = true;
      toggleSubtitlesElement.nextElementSibling.querySelector('.toggle-text').textContent = 'BẬT';
      errorMessage.style.display = 'none';
      console.log('Đã xóa tất cả dữ liệu và đặt lại trạng thái.');
    });

    // Handle fullscreen change
    video.addEventListener('fullscreenchange', updateSubtitles);

    // Adjust on resize
    window.addEventListener('resize', updateSubtitles);

    // Initial update on video load
    video.addEventListener('loadedmetadata', () => {
      updateSubtitles();
      loopEnd = video.duration;
      loopEndElement.textContent = formatTime(loopEnd);
    });

    // Handle play or playing
    video.addEventListener('play', updateSubtitles);
    video.addEventListener('playing', updateSubtitles);

    // Close popup
    function closePopup() {
      translationPopup.style.display = 'none';
    }

    // Close popup on click outside
    document.addEventListener('click', (e) => {
      if (!translationPopup.contains(e.target) && !e.target.classList.contains('subtitle') && e.target !== subtitleDisplay) {
        closePopup();
      }
    });

    // Make popup draggable
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;

    translationPopup.addEventListener('mousedown', (e) => {
      initialX = e.clientX - (currentX || 0);
      initialY = e.clientY - (currentY || 0);
      isDragging = true;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        translationPopup.style.left = `${currentX}px`;
        translationPopup.style.top = `${currentY}px`;
        translationPopup.style.transform = 'none';
        localStorage.setItem('popupPosition', JSON.stringify({ top: currentY, left: currentX }));
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Restore popup position
    function restorePopupPosition() {
      const savedPosition = localStorage.getItem('popupPosition');
      if (savedPosition) {
        const { top, left } = JSON.parse(savedPosition);
        translationPopup.style.top = `${top}px`;
        translationPopup.style.left = `${left}px`;
        translationPopup.style.transform = 'none';
        currentX = left;
        currentY = top;
      } else {
        translationPopup.style.top = '20%';
        translationPopup.style.left = '50%';
        translationPopup.style.transform = 'translateX(-50%)';
        currentX = 0;
        currentY = 0;
      }
    }

    // Translate word using Gemini API with key rotation
    async function translateWord(word, targetElement) {
      popupContent.innerHTML = 'Đang dịch...';
      translationPopup.style.display = 'block';
      restorePopupPosition();

      const cleanedWord = word.replace(/[^a-zA-Zä-üÄ-Ü\s\-\']/g, '').trim();
      const sentence = currentSentence || cleanedWord;

      const translationPrompt = `
        Yêu cầu:
        **Đầu tiên, loại bỏ các định dạng không thuộc ngôn ngữ của "${cleanedWord}" và "${sentence}" (loại bỏ thẻ HTML, ký tự đặc biệt không thuộc tiếng Đức).**
        **Tiếp theo, phân tích từ/cụm từ "${cleanedWord}" trong câu "${sentence}" và trả về bản dịch sang tiếng Việt.**

        Trả về duy nhất cấu trúc JSON theo mẫu sau:
          {
            "tugoc": "Từ gốc (Động từ: dạng nguyên thể, kèm tiền tố tách nếu có; Danh từ: dạng số ít kèm mạo từ; giữ nguyên nếu là cụm từ/câu)",
            "nghia": "<Loại từ>: <Nghĩa 1>, <Nghĩa 2>, ... (kết hợp loại từ và các nghĩa tiếng Việt, ưu tiên nhiều nghĩa nếu có)"
          }

        A. Xác định loại từ của "${cleanedWord}":
          1. Câu: Nếu "${cleanedWord}" có chủ ngữ, vị ngữ và dấu câu cuối (., !, ?), hoặc cấu trúc ngữ pháp đầy đủ.
            - tugoc: "${cleanedWord}" (giữ nguyên)
            - nghia: "Câu: <Nghĩa tiếng Việt của câu>"
          2. Cụm từ: Nếu "${cleanedWord}" có hai từ trở lên nhưng không phải câu hoàn chỉnh.
            - tugoc: "${cleanedWord}" (giữ nguyên)
            - nghia: "Cụm từ: <Nghĩa tiếng Việt chính xác>"
          3. Từ đơn: Nếu "${cleanedWord}" là một từ.
            - Động từ tách: Kiểm tra "${sentence}" để tìm tiền tố tách (ab|an|auf|aus|bei|da|ein|fest|her|hin|los|mit|nach|statt|teil|vor|weg|zu|zurück|zusammen) ở cuối câu hoặc trước liên từ (und/oder/aber). Chuyển về nguyên thể và ghép tiền tố (ví dụ: "mach" + "aus" → "ausmachen").
            - Động từ phản thân: Tìm "sich|mich|dich|eur|uns" (ví dụ: "sich ändern").
            - Động từ kèm giới từ: Xác định giới từ (ví dụ: "teilnehmen an").
            - Danh từ: Nếu viết hoa, thêm mạo từ (der|die|das, tham khảo duden.de).
            - Tính từ/Trạng từ/Đại từ/Giới từ/Liên từ/Thán từ: Dùng dạng gốc.
            - tugoc: Dạng đúng theo loại từ (ví dụ: "ausmachen", "der Tisch").
            - nghia: "<Loại từ>: <Nghĩa 1>, <Nghĩa 2>, ..."

        Lưu ý:
          - Xác định chính xác loại từ, không cắt xén "${cleanedWord}".
          - Chỉ đưa ra nghĩa riêng cho "${cleanedWord}", không bao gồm nghĩa của từ khác trong "${sentence}".
          - Ưu tiên ngữ cảnh "${sentence}".
          - Tham khảo dict.cc/leo.org/duden.de.
          - Trả về JSON thuần hợp lệ trong \`\`\`json\n...\n\`\`\`.
      `;

      async function tryTranslateWithKey(keyIndex) {
        const apiKey = apiKeys[keyIndex];
        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: translationPrompt
                }]
              }]
            })
          });

          if (!response.ok) {
            if (response.status === 429 && keyIndex < apiKeys.length - 1) {
              console.warn(`API key ${keyIndex} đã vượt giới hạn, thử key tiếp theo.`);
              return tryTranslateWithKey(keyIndex + 1);
            }
            throw new Error(`Lỗi HTTP: ${response.status}`);
          }

          const data = await response.json();
          const content = data.candidates[0].content.parts[0].text;
          const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
          if (!jsonMatch) {
            throw new Error('Phản hồi từ API không chứa JSON hợp lệ.');
          }
          const jsonData = JSON.parse(jsonMatch[1]);

          // Kiểm tra dữ liệu JSON
          if (!jsonData.tugoc || !jsonData.nghia) {
            throw new Error('Dữ liệu JSON không đầy đủ: Thiếu tugoc hoặc nghia.');
          }

          popupContent.innerHTML = `
            <p><strong>Từ gốc:</strong> ${jsonData.tugoc}</p>
            <p><strong>Nghĩa:</strong> ${jsonData.nghia}</p>
          `;
          translationPopup.style.display = 'block';
          restorePopupPosition();
        } catch (error) {
          if (keyIndex < apiKeys.length - 1) {
            console.warn(`Key API ${keyIndex} thất bại: ${error.message}, thử key tiếp theo.`);
            return tryTranslateWithKey(keyIndex + 1);
          } else {
            popupContent.innerHTML = `<p>Lỗi khi dịch "${cleanedWord}": ${error.message}</p>`;
            translationPopup.style.display = 'block';
            restorePopupPosition();
            console.error('Tất cả API key thất bại:', error);
          }
        }
      }

      if (apiKeys.length === 0 || apiKeys[0] === 'YOUR_API_KEY_1') {
        popupContent.innerHTML = '<p>Chưa cung cấp API key hợp lệ. Vui lòng thêm key Gemini API vào mã.</p>';
        translationPopup.style.display = 'block';
        restorePopupPosition();
        console.error('Không có API key hợp lệ.');
        return;
      }

      tryTranslateWithKey(currentApiKeyIndex);
    }

    // Initialize
    loadFromLocalStorage();
  </script>
</body>
</html>