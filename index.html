<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üõ∏Video Player v·ªõi Ph·ª• ƒë·ªÅ, D·ªãch v√† L·∫∑p ƒëo·∫°nüõ∏</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .video-container {
      position: relative;
      width: 95%;
      margin: 0 auto;
    }
    #video-player {
      width: 100%;
      height: auto;
      display: block;
    }
    #subtitles {
      position: absolute;
      bottom: 15%;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      padding: 10px;
      pointer-events: auto;
      z-index: 2147483647;
      display: block;
      visibility: visible;
      white-space: pre-wrap;
      line-height: 1.2;
      transform: translateZ(0);
      contain: paint;
    }
    .subtitle {
      cursor: pointer;
      display: inline;
      margin: 0 0.05em;
      padding: 2px 3px;
      letter-spacing: -0.02em;
      transition: color 0.2s;
    }
    .subtitle:hover {
      color: orange;
    }
    .selected {
      color: yellow;
      font-weight: bold;
    }
    #error-message {
      color: red;
      display: none;
      margin-bottom: 1rem;
      text-align: center;
    }
    #translation-popup {
      display: none;
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      z-index: 2147483648;
      max-width: 400px;
      font-size: 0.9rem;
      cursor: move;
      user-select: none;
    }
    #translation-popup .close-btn {
      position: absolute;
      top: 5px;
      right: 10px;
      cursor: pointer;
      font-size: 1.2rem;
    }
    .input-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 1rem;
      z-index: 2147483646;
    }
    .input-box {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      width: 80%;
      max-width: 400px;
    }
    .custom-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #f1f1f1;
      padding: 5px;
      border-radius: 0 0 8px 8px;
      width: 95%;
      margin: 0 auto;
      flex-wrap: wrap;
    }
    .custom-controls button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }
    .custom-controls button:hover {
      background: #45a049;
    }
    #clear-data {
      background: #f44336;
    }
    #clear-data:hover {
      background: #da190b;
    }
    .custom-controls span {
      font-size: 12px;
      color: #333;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 24px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #ccc;
      transition: 0.4s;
      border-radius: 24px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      color: white;
      font-size: 10px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: white;
      transition: 0.4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background: #4CAF50;
    }
    input:checked + .slider:before {
      transform: translateX(36px);
    }
    .toggle-text {
      margin-left: 5px;
    }
    .loop-list-container {
      margin-top: 1rem;
      background: white;
      padding: 1rem;
      border-radius: 8px;
      width: 95%;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    #loop-list {
      list-style: none;
      padding: 0;
      max-height: 150px;
      overflow-y: auto;
    }
    #loop-list li {
      padding: 0.5rem;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #loop-list li:hover {
      background-color: #f0f0f0;
    }
    .delete-loop {
      color: red;
      cursor: pointer;
    }
    #loop-markers {
      position: relative;
      height: 2rem;
      width: 100%;
      margin-top: -10px;
      z-index: 100;
    }
    .loop-marker {
      position: absolute;
      width: 24px;
      height: 24px;
      background: #4CAF50;
      color: white;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      line-height: 24px;
      transform: translateX(-50%);
    }
    .loop-marker:nth-child(odd) {
      top: -25px;
    }
    .loop-marker:nth-child(even) {
      bottom: -25px;
    }
  </style>
</head>
<body class="bg-gray-100 font-sans">
  <div class="container mx-auto p-4">
    
    <div id="error-message" class="mb-4"></div>
    
    <div class="video-container">
      <video id="video-player" controls></video>
      <div class="custom-controls">
        <button id="set-loop-start" title="ƒê·∫∑t th·ªùi gian b·∫Øt ƒë·∫ßu l·∫∑p">B·∫Øt ƒë·∫ßu</button>
        <span id="loop-start-display">00:00</span>
        <button id="set-loop-end" title="ƒê·∫∑t th·ªùi gian k·∫øt th√∫c l·∫∑p">K·∫øt th√∫c</button>
        <span id="loop-end-display">00:00</span>
        <button id="add-loop" title="Th√™m ƒëo·∫°n l·∫∑p">Th√™m</button>
        <label class="toggle-switch">
          <input type="checkbox" id="toggle-loop">
          <span class="slider" title="B·∫≠t/T·∫Øt l·∫∑p ƒëo·∫°n">L·∫∑p: <span class="toggle-text">OFF</span></span>
        </label>
        <label class="toggle-switch">
          <input type="checkbox" id="toggle-subtitles" checked>
          <span class="slider" title="B·∫≠t/T·∫Øt ph·ª• ƒë·ªÅ">Ph·ª• ƒë·ªÅ: <span class="toggle-text">ON</span></span>
        </label>
        <button id="clear-data" title="X√≥a video, ph·ª• ƒë·ªÅ, ƒëo·∫°n l·∫∑p">X√≥a</button>
      </div>
      <div id="loop-markers"></div>
      <div id="subtitles"></div>
      <div id="input-overlay" class="input-overlay">
        <div class="input-box">
          <label class="block mb-2">Nh·∫≠p URL Video ho·∫∑c T·∫£i l√™n File:</label>
          <input type="text" id="video-url" placeholder="Nh·∫≠p URL video (v√≠ d·ª•: https://example.com/video.mp4)" class="border p-2 w-full mb-2">
          <input type="file" id="video-upload" accept="video/*" class="border p-2 w-full">
        </div>
        <div class="input-box">
          <label class="block mb-2">T·∫£i l√™n File SRT:</label>
          <input type="file" id="subtitle-upload" accept=".srt" class="border p-2 w-full">
        </div>
      </div>
      <div id="translation-popup">
        <span class="close-btn" onclick="closePopup()">√ó</span>
        <div id="popup-content"></div>
      </div>
    </div>

    <div class="loop-list-container">
      <h4 class="font-bold">Danh s√°ch ƒëo·∫°n l·∫∑p</h4>
      <ul id="loop-list"></ul>
    </div>
  </div>

  <script>
    const video = document.getElementById('video-player');
    const videoContainer = document.querySelector('.video-container');
    const inputOverlay = document.getElementById('input-overlay');
    const videoUrlInput = document.getElementById('video-url');
    const videoUpload = document.getElementById('video-upload');
    const subtitleUpload = document.getElementById('subtitle-upload');
    const subtitlesDiv = document.getElementById('subtitles');
    const translationPopup = document.getElementById('translation-popup');
    const popupContent = document.getElementById('popup-content');
    const errorMessage = document.getElementById('error-message');
    const setLoopStartElement = document.getElementById('set-loop-start');
    const setLoopEndElement = document.getElementById('set-loop-end');
    const loopStartElement = document.getElementById('loop-start-display');
    const loopEndElement = document.getElementById('loop-end-display');
    const addLoopElement = document.getElementById('add-loop');
    const toggleLoopElement = document.getElementById('toggle-loop');
    const toggleSubtitlesElement = document.getElementById('toggle-subtitles');
    const clearDataElement = document.getElementById('clear-data');
    const loopListElement = document.getElementById('loop-list');
    const loopMarkersElement = document.getElementById('loop-markers');
    let subtitles = [];
    let currentSentence = '';
    let isVideoLoaded = false;
    let isSubtitlesLoaded = false;
    let hasPlayed = false;
    let isLooping = false;
    let subtitleEnabled = true;
    let loopStart = 0;
    let loopEnd = 0;
    let loops = [];
    const debounceDelay = 100;

    // API keys
    const apiKeys = [
      'AIzaSyBGBardF0wcqPoHXwUUcRQuS5H3PI7fmCE', // Replace with your first Gemini API key
      'AIzaSyDZ16xv4yuq39Epui20WXU7N1tQn5Ef5-8', // Replace with your second Gemini API key
      // Add more keys as needed
    ];
    let currentApiKeyIndex = 0;

    // Format time to MM:SS
    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Load from localStorage
    function loadFromLocalStorage() {
      const videoUrl = localStorage.getItem('videoUrl');
      const videoFileName = localStorage.getItem('videoFileName');
      const srtContent = localStorage.getItem('subtitleContent');
      const loopList = localStorage.getItem('loopList');
      const loopEnabled = localStorage.getItem('loopEnabled');
      const subtitleEnabledStored = localStorage.getItem('subtitleEnabled');

      // Load video
      if (videoUrl) {
        try {
          video.src = videoUrl;
          video.load();
          isVideoLoaded = true;
          console.log('Loaded video from URL:', videoUrl);
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `L·ªói t·∫£i video t·ª´ localStorage: ${error.message}`;
          console.error('Video URL load error:', error);
        }
      } else if (videoFileName) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = `Vui l√≤ng t·∫£i l·∫°i file video: ${videoFileName}`;
        console.log('Local video file detected, prompting reload:', videoFileName);
        isVideoLoaded = false;
      }

      // Load subtitles
      if (srtContent) {
        try {
          subtitles = parseSRT(srtContent);
          isSubtitlesLoaded = subtitles.length > 0;
          displaySubtitles();
          console.log('Loaded subtitles from localStorage:', subtitles.length, 'blocks');
          if (!isSubtitlesLoaded) {
            errorMessage.style.display = 'block';
            errorMessage.textContent = 'Kh√¥ng t√¨m th·∫•y ph·ª• ƒë·ªÅ h·ª£p l·ªá trong d·ªØ li·ªáu l∆∞u tr·ªØ. T·∫£i l·∫°i file SRT.';
            console.warn('No valid subtitles parsed from localStorage.');
          }
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `L·ªói kh√¥i ph·ª•c ph·ª• ƒë·ªÅ: ${error.message}. T·∫£i l·∫°i file SRT.`;
          console.error('Subtitle load error:', error);
          isSubtitlesLoaded = false;
        }
      }

      // Load loop list
      if (loopList) {
        try {
          loops = JSON.parse(loopList);
          updateLoopList();
          console.log('Loaded loop list:', loops);
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `L·ªói t·∫£i danh s√°ch l·∫∑p: ${error.message}`;
          console.error('Loop list load error:', error);
        }
      }

      // Load loop toggle
      isLooping = loopEnabled !== null ? JSON.parse(loopEnabled) : false;
      toggleLoopElement.checked = isLooping;
      toggleLoopElement.nextElementSibling.querySelector('.toggle-text').textContent = isLooping ? 'ON' : 'OFF';
      console.log('Loop toggle state:', isLooping);

      // Load subtitle toggle
      subtitleEnabled = subtitleEnabledStored !== null ? JSON.parse(subtitleEnabledStored) : true;
      toggleSubtitlesElement.checked = subtitleEnabled;
      toggleSubtitlesElement.nextElementSibling.querySelector('.toggle-text').textContent = subtitleEnabled ? 'ON' : 'OFF';
      subtitlesDiv.style.display = subtitleEnabled ? 'block' : 'none';
      console.log('Subtitle toggle state:', subtitleEnabled);

      // Update subtitles display
      if (isSubtitlesLoaded && subtitleEnabled) {
        updateSubtitles();
      }

      tryPlayVideo();
    }

    // Parse SRT file content
    function parseSRT(data) {
      try {
        // Lo·∫°i b·ªè BOM v√† chu·∫©n h√≥a d√≤ng
        let normalizedData = data.replace(/\uFEFF/g, '').replace(/\r\n|\r|\n/g, '\n').trim();
        // T√°ch block, b·ªè block tr·ªëng
        const blocks = normalizedData.split(/\n\n+/).filter(block => block.trim());
        if (!blocks.length) {
          throw new Error('File SRT tr·ªëng ho·∫∑c kh√¥ng ch·ª©a block h·ª£p l·ªá.');
        }
        const parsedSubtitles = [];
        blocks.forEach((block, index) => {
          try {
            const lines = block.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
              console.warn(`Block ${index + 1} b·ªã b·ªè qua: Kh√¥ng ƒë·ªß d√≤ng.`);
              return;
            }
            // T√¨m d√≤ng th·ªùi gian
            let timeLineIndex = lines.findIndex(line => line.includes(' --> '));
            if (timeLineIndex === -1) {
              console.warn(`Block ${index + 1} b·ªã b·ªè qua: Kh√¥ng t√¨m th·∫•y d√≤ng th·ªùi gian.`);
              return;
            }
            // B·ªè qua s·ªë th·ª© t·ª± (n·∫øu c√≥)
            if (timeLineIndex > 0 && /^\d+$/.test(lines[0])) {
              lines.splice(0, 1);
              timeLineIndex--;
            }
            const timeLine = lines[timeLineIndex];
            const contentLines = lines.slice(timeLineIndex + 1).filter(line => line.trim());
            if (!contentLines.length) {
              console.warn(`Block ${index + 1} b·ªã b·ªè qua: Kh√¥ng c√≥ n·ªôi dung ph·ª• ƒë·ªÅ.`);
              return;
            }
            // Ph√¢n t√≠ch th·ªùi gian
            const [start, end] = timeLine.split(' --> ').map(t => {
              const timeStr = t.replace(',', '.').trim();
              const [h, m, s] = timeStr.split(':');
              if (isNaN(h) || isNaN(m) || isNaN(s)) {
                throw new Error(`ƒê·ªãnh d·∫°ng th·ªùi gian kh√¥ng h·ª£p l·ªá: ${t}`);
              }
              return parseInt(h) * 3600 + parseInt(m) * 60 + parseFloat(s);
            });
            if (start >= end) {
              console.warn(`Block ${index + 1} b·ªã b·ªè qua: Th·ªùi gian b·∫Øt ƒë·∫ßu (${start}) >= k·∫øt th√∫c (${end}).`);
              return;
            }
            parsedSubtitles.push({ startTime: start, endTime: end, contentLines });
          } catch (blockError) {
            console.error(`L·ªói ·ªü block ${index + 1}: ${blockError.message}`);
          }
        });
        if (!parsedSubtitles.length) {
          throw new Error('Kh√¥ng t√¨m th·∫•y block ph·ª• ƒë·ªÅ h·ª£p l·ªá n√†o trong file.');
        }
        console.log(`Parsed ${parsedSubtitles.length} subtitle blocks successfully.`);
        return parsedSubtitles;
      } catch (error) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = `L·ªói ph√¢n t√≠ch file SRT: ${error.message}. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng SRT v√† ƒë·∫£m b·∫£o m√£ h√≥a UTF-8.`;
        console.error('SRT parsing error:', error);
        return [];
      }
    }

    // Update loop markers
    function updateLoopMarkers() {
      loopMarkersElement.innerHTML = '';
      loops.forEach((loop, index) => {
        const marker = document.createElement('div');
        marker.className = 'loop-marker';
        marker.textContent = index + 1;
        const positionPercent = (loop.start / video.duration) * 100;
        marker.style.left = `${positionPercent}%`;
        marker.addEventListener('click', () => {
          video.currentTime = loop.start;
          video.play();
          if (isLooping) {
            loopStart = loop.start;
            loopEnd = loop.end;
            loopStartElement.textContent = formatTime(loopStart);
            loopEndElement.textContent = formatTime(loopEnd);
          }
        });
        loopMarkersElement.appendChild(marker);
      });
    }

    // Update loop list
    function updateLoopList() {
      loopListElement.innerHTML = '';
      loops.forEach((loop, index) => {
        const li = document.createElement('li');
        li.innerHTML = `${formatTime(loop.start)} ‚Üí ${formatTime(loop.end)} <span class="delete-loop">X√≥a</span>`;
        li.addEventListener('click', (e) => {
          if (e.target.classList.contains('delete-loop')) {
            loops.splice(index, 1);
            updateLoopList();
            localStorage.setItem('loopList', JSON.stringify(loops));
            updateLoopMarkers();
            return;
          }
          video.currentTime = loop.start;
          video.play();
          if (isLooping) {
            loopStart = loop.start;
            loopEnd = loop.end;
            loopStartElement.textContent = formatTime(loopStart);
            loopEndElement.textContent = formatTime(loopEnd);
          }
        });
        loopListElement.appendChild(li);
      });
      updateLoopMarkers();
      localStorage.setItem('loopList', JSON.stringify(loops));
    }

    // Set loop start
    setLoopStartElement.addEventListener('click', () => {
      loopStart = video.currentTime;
      loopStartElement.textContent = formatTime(loopStart);
    });

    // Set loop end
    setLoopEndElement.addEventListener('click', () => {
      loopEnd = video.currentTime;
      loopEndElement.textContent = formatTime(loopEnd);
    });

    // Add loop
    addLoopElement.addEventListener('click', () => {
      if (loopStart >= loopEnd || loopStart < 0 || loopEnd > video.duration) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Th·ªùi gian l·∫∑p kh√¥ng h·ª£p l·ªá. ƒê·∫£m b·∫£o B·∫Øt ƒë·∫ßu < K·∫øt th√∫c v√† trong ph·∫°m vi video.';
        return;
      }
      loops.push({ start: loopStart, end: loopEnd });
      updateLoopList();
      loopStart = 0;
      loopEnd = 0;
      loopStartElement.textContent = '00:00';
      loopEndElement.textContent = '00:00';
      errorMessage.style.display = 'none';
    });

    // Toggle loop
    toggleLoopElement.addEventListener('change', () => {
      isLooping = toggleLoopElement.checked;
      toggleLoopElement.nextElementSibling.querySelector('.toggle-text').textContent = isLooping ? 'ON' : 'OFF';
      localStorage.setItem('loopEnabled', isLooping);
      if (!isLooping) {
        loopStart = 0;
        loopEnd = video.duration || 0;
        loopStartElement.textContent = '00:00';
        loopEndElement.textContent = formatTime(loopEnd);
      }
      console.log('Loop toggle changed:', isLooping);
    });

    // Toggle subtitles
    toggleSubtitlesElement.addEventListener('change', () => {
      subtitleEnabled = toggleSubtitlesElement.checked;
      subtitlesDiv.style.display = subtitleEnabled ? 'block' : 'none';
      toggleSubtitlesElement.nextElementSibling.querySelector('.toggle-text').textContent = subtitleEnabled ? 'ON' : 'OFF';
      localStorage.setItem('subtitleEnabled', subtitleEnabled);
      if (subtitleEnabled) updateSubtitles();
      console.log('Subtitle toggle changed:', subtitleEnabled);
    });

    // Clear data
    clearDataElement.addEventListener('click', () => {
      localStorage.removeItem('videoUrl');
      localStorage.removeItem('videoFileName');
      localStorage.removeItem('subtitleContent');
      localStorage.removeItem('loopList');
      localStorage.removeItem('loopEnabled');
      localStorage.removeItem('subtitleEnabled');
      video.src = '';
      video.load();
      subtitles = [];
      loops = [];
      isVideoLoaded = false;
      isSubtitlesLoaded = false;
      hasPlayed = false;
      isLooping = false;
      subtitleEnabled = true;
      inputOverlay.style.display = 'flex';
      subtitlesDiv.innerHTML = '';
      subtitlesDiv.style.display = 'none';
      loopListElement.innerHTML = '';
      loopMarkersElement.innerHTML = '';
      loopStartElement.textContent = '00:00';
      loopEndElement.textContent = '00:00';
      toggleLoopElement.checked = false;
      toggleLoopElement.nextElementSibling.querySelector('.toggle-text').textContent = 'OFF';
      toggleSubtitlesElement.checked = true;
      toggleSubtitlesElement.nextElementSibling.querySelector('.toggle-text').textContent = 'ON';
      errorMessage.style.display = 'none';
      console.log('Cleared all data and reset state.');
    });

    // Handle looping
    function handleLooping() {
      if (isLooping && video.currentTime >= loopEnd) {
        video.currentTime = loopStart;
        video.play();
      }
    }

    // Update subtitles
    function updateSubtitles() {
      if (!subtitleEnabled) {
        subtitlesDiv.style.display = 'none';
        return;
      }
      const isFullscreen = !!document.fullscreenElement;
      const videoRect = video.getBoundingClientRect();
      const videoHeight = videoRect.height;
      const windowHeight = window.innerHeight;
      const fontSizePx = isFullscreen ? windowHeight * 0.06 : videoHeight * 0.06;

      subtitlesDiv.style.position = 'absolute';
      subtitlesDiv.style.bottom = '15%';
      subtitlesDiv.style.left = '0';
      subtitlesDiv.style.right = '0';
      subtitlesDiv.style.width = `${videoRect.width}px`;
      subtitlesDiv.style.zIndex = '2147483647';
      subtitlesDiv.style.fontSize = `${fontSizePx}px`;
      subtitlesDiv.style.textShadow = `2px 2px 4px rgba(0, 0, 0, 0.8)`;
      subtitlesDiv.style.display = 'block';
      subtitlesDiv.style.willChange = 'transform, opacity';

      requestAnimationFrame(() => {
        setTimeout(() => {
          subtitlesDiv.style.visibility = 'visible';
          subtitlesDiv.style.willChange = 'auto';
        }, 0);
      });
    }

    // Handle fullscreen change
    video.addEventListener('fullscreenchange', updateSubtitles);

    // Adjust on resize
    window.addEventListener('resize', updateSubtitles);

    // Initial update on video load
    video.addEventListener('loadedmetadata', () => {
      updateSubtitles();
      loopEnd = video.duration;
      loopEndElement.textContent = formatTime(loopEnd);
    });

    // Handle play or playing
    video.addEventListener('play', updateSubtitles);
    video.addEventListener('playing', updateSubtitles);

    // Initialize subtitle display
    function displaySubtitles() {
      subtitlesDiv.innerHTML = subtitles.length ? '' : 'Ch∆∞a t·∫£i ph·ª• ƒë·ªÅ. Vui l√≤ng t·∫£i file SRT h·ª£p l·ªá.';
      errorMessage.style.display = 'none';
      updateSubtitles();
    }

    // Try to play video
    function tryPlayVideo() {
      if (isVideoLoaded && isSubtitlesLoaded && !hasPlayed) {
        inputOverlay.style.display = 'none';
        video.play().then(() => {
          hasPlayed = true;
        }).catch(e => {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `L·ªói ph√°t video: ${e.message}`;
          inputOverlay.style.display = 'flex';
        });
      }
    }

    // Load video from URL
    videoUrlInput.addEventListener('input', () => {
      const url = videoUrlInput.value.trim();
      if (url) {
        try {
          video.src = url;
          video.load();
          isVideoLoaded = true;
          localStorage.setItem('videoUrl', url);
          localStorage.removeItem('videoFileName');
          errorMessage.style.display = 'none';
          console.log('Loaded video from URL:', url);
          tryPlayVideo();
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `L·ªói t·∫£i video t·ª´ URL: ${error.message}`;
          console.error('Video URL load error:', error);
          isVideoLoaded = false;
          localStorage.removeItem('videoUrl');
        }
      }
    });

    // Load video from file
    videoUpload.addEventListener('change', (e) => {
      const videoFile = e.target.files[0];
      if (videoFile) {
        try {
          const fileUrl = URL.createObjectURL(videoFile);
          video.src = fileUrl;
          video.load();
          isVideoLoaded = true;
          localStorage.setItem('videoFileName', videoFile.name);
          localStorage.removeItem('videoUrl');
          errorMessage.style.display = 'none';
          console.log('Loaded local video file:', videoFile.name);
          tryPlayVideo();
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `L·ªói t·∫£i file video: ${error.message}`;
          console.error('Video file load error:', error);
          isVideoLoaded = false;
          localStorage.removeItem('videoFileName');
        }
      }
    });

    // Load and display subtitles
    subtitleUpload.addEventListener('change', (e) => {
      const subtitleFile = e.target.files[0];
      if (!subtitleFile) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Ch∆∞a ch·ªçn file SRT.';
        console.error('No SRT file selected.');
        return;
      }
      if (!subtitleFile.name.toLowerCase().endsWith('.srt')) {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Vui l√≤ng t·∫£i file .srt h·ª£p l·ªá.';
        console.error('Invalid file extension:', subtitleFile.name);
        return;
      }
      const fileReader = new FileReader();
      fileReader.onload = (event) => {
        try {
          const subtitleText = event.target.result;
          console.log('SRT file loaded, size:', subtitleText.length, 'characters');
          subtitles = parseSRT(subtitleText);
          isSubtitlesLoaded = subtitles.length > 0;
          localStorage.setItem('subtitleContent', subtitleText);
          displaySubtitles();
          if (subtitles.length === 0) {
            errorMessage.style.display = 'block';
            errorMessage.textContent = 'Kh√¥ng t√¨m th·∫•y ph·ª• ƒë·ªÅ h·ª£p l·ªá trong file SRT. Ki·ªÉm tra ƒë·ªãnh d·∫°ng v√† m√£ h√≥a UTF-8.';
            console.warn('No valid subtitles parsed.');
          } else {
            errorMessage.style.display = 'none';
            console.log('Subtitles loaded successfully:', subtitles);
            tryPlayVideo();
          }
        } catch (error) {
          errorMessage.style.display = 'block';
          errorMessage.textContent = `L·ªói ƒë·ªçc file SRT: ${error.message}`;
          console.error('SRT reading error:', error);
          isSubtitlesLoaded = false;
        }
      };
      fileReader.onerror = () => {
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'L·ªói ƒë·ªçc file SRT. Vui l√≤ng th·ª≠ l·∫°i.';
        console.error('FileReader error for SRT file.');
        isSubtitlesLoaded = false;
      };
      fileReader.readAsText(subtitleFile, 'UTF-8');
    });

    // Debounce function
    function debounce(func, delay) {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func(...args), delay);
      };
    }

    // Update subtitles on timeupdate
    video.addEventListener('timeupdate', debounce(() => {
      if (video.paused) return;
      handleLooping();
      const currentTime = video.currentTime;
      const currentSubtitle = subtitles.find(sub => sub.startTime <= currentTime && currentTime <= sub.endTime);
      currentSentence = currentSubtitle ? currentSubtitle.contentLines.join(' ') : '';
      const newSubtitleText = currentSubtitle ? currentSubtitle.contentLines.join('<br>') : '';
      subtitlesDiv.innerHTML = newSubtitleText;
      makeWordsSelectable();
      updateSubtitles();
    }, debounceDelay));

    // Make subtitle words selectable
    function makeWordsSelectable() {
      const subtitleText = subtitlesDiv.innerHTML;
      if (subtitleText) {
        const subtitleLines = subtitleText.split('<br>').map(line => {
          const words = line.split(' ').map(word => `<span class="subtitle">${word}</span>`).join(' ');
          return words;
        });
        subtitlesDiv.innerHTML = subtitleLines.join('<br>');
      }
    }

    // Handle subtitle word click
    subtitlesDiv.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      e.preventDefault();
      const subtitleTarget = e.target.closest('.subtitle');
      if (!subtitleTarget) return;
      document.querySelectorAll('.subtitle').forEach(w => w.classList.remove('selected'));
      subtitleTarget.classList.add('selected');
      video.pause();
      translateWord(subtitleTarget.textContent, subtitleTarget);
    });

    // Close popup
    function closePopup() {
      translationPopup.style.display = 'none';
    }

    // Close popup on click outside
    document.addEventListener('click', (e) => {
      if (!translationPopup.contains(e.target) && !e.target.classList.contains('subtitle')) {
        closePopup();
      }
    });

    // Make popup draggable
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;

    translationPopup.addEventListener('mousedown', (e) => {
      initialX = e.clientX - currentX;
      initialY = e.clientY - currentY;
      isDragging = true;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        translationPopup.style.left = `${currentX}px`;
        translationPopup.style.top = `${currentY}px`;
        translationPopup.style.transform = 'none';
        localStorage.setItem('popupPosition', JSON.stringify({ top: currentY, left: currentX }));
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Restore popup position
    function restorePopupPosition() {
      const savedPosition = localStorage.getItem('popupPosition');
      if (savedPosition) {
        const { top, left } = JSON.parse(savedPosition);
        translationPopup.style.top = `${top}px`;
        translationPopup.style.left = `${left}px`;
        translationPopup.style.transform = 'none';
        currentX = left;
        currentY = top;
      } else {
        translationPopup.style.top = '20%';
        translationPopup.style.left = '50%';
        translationPopup.style.transform = 'translateX(-50%)';
        currentX = 0;
        currentY = 0;
      }
    }

    // Translate word using Gemini API with key rotation
    async function translateWord(word, targetElement) {
      popupContent.innerHTML = 'ƒêang d·ªãch...';
      translationPopup.style.display = 'block';
      restorePopupPosition();

      const cleanedWord = word.replace(/[^a-zA-Z√§-√º√Ñ-√ú\s\-\']/g, '').trim();
      const sentence = currentSentence || cleanedWord;

      const translationPrompt = `
        Y√™u c·∫ßu:
        **ƒê·∫ßu ti√™n ph·∫£i lo·∫°i b·ªè c√°c ƒë·ªãnh d·∫°ng kh√¥ng thu·ªôc ng√¥n ng·ªØ c·ªßa "${cleanedWord}" v√† "${sentence}" (lo·∫°i b·ªè c√°c th·∫ª HTML, c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát kh√¥ng thu·ªôc ti·∫øng ƒê·ª©c).
        **Ti·∫øp t·ª•c ph√¢n t√≠ch t·ª´/c·ª•m t·ª´ "${cleanedWord}" trong c√¢u "${sentence}" v√† tr·∫£ v·ªÅ b·∫£n d·ªãch sang ti·∫øng Vi·ªát.

          Tr·∫£ v·ªÅ duy nh·∫•t c·∫•u tr√∫c JSON theo m·∫´u sau:
            {
              "tugoc": "T·ª´ g·ªëc (ƒê·ªông t·ª´: d·∫°ng nguy√™n th·ªÉ, k√®m ti·ªÅn t·ªë t√°ch n·∫øu c√≥; Danh t·ª´: d·∫°ng s·ªë √≠t nh·∫•t k√®m m·∫°o t·ª´; gi·ªØ nguy√™n n·∫øu l√† c·ª•m t·ª´/c√¢u)",
              "nghia": "<Lo·∫°i t·ª´>: <Nghƒ©a 1>, <Nghƒ©a 2>, ... (k·∫øt h·ª£p lo·∫°i t·ª´ v√† c√°c nghƒ©a Ti·∫øng Vi·ªát, ∆∞u ti√™n nhi·ªÅu nghƒ©a n·∫øu c√≥)"
            }

          A. X√°c ƒë·ªãnh lo·∫°i t·ª´ c·ªßa "${cleanedWord}":
             1. C√¢u: N·∫øu "${cleanedWord}" c√≥ ch·ªß ng·ªØ, v·ªã ng·ªØ, v√† d·∫•u c√¢u cu·ªëi (., !, ?), ho·∫∑c c·∫•u tr√∫c ng·ªØ ph√°p ƒë·∫ßy ƒë·ªß.
                - tugoc: "${cleanedWord}" (kh√¥ng th√™m b·ªõt)
                - nghia: "C√¢u: <Nghƒ©a Ti·∫øng Vi·ªát c·ªßa c√¢u)"
             2. C·ª•m t·ª´: N·∫øu "${cleanedWord}" c√≥ hai t·ª´ tr·ªü l√™n nh∆∞ng kh√¥ng ph·∫£i c√¢u ho√†n ch·ªânh.
                - tugoc: "${cleanedWord}" (kh√¥ng th√™m b·ªõt)
                - nghia: "C·ª•m t·ª´: <Nghƒ©a Ti·∫øng Vi·ªát ch√≠nh x√°c>"
             3. T·ª´ ƒë∆°n: N·∫øu "${cleanedWord}" l√† m·ªôt t·ª´.
                - ƒê·ªông t·ª´ t√°ch: Ki·ªÉm tra "${sentence}" ƒë·ªÉ t√¨m ti·ªÅn t·ªë t√°ch (ab|an|auf|aus|bei|da|ein|fest|her|hin|los|mit|nach|statt|teil|vor|weg|zu|zur√ºck|zusammen) ·ªü cu·ªëi c√¢u ho·∫∑c tr∆∞·ªõc li√™n t·ª´ (und/oder/aber). Chuy·ªÉn v·ªÅ nguy√™n th·ªÉ v√† gh√©p ti·ªÅn t·ªë (v√≠ d·ª•: "mach" + "aus" ‚Üí "ausmachen").
                - ƒê·ªông t·ª´ ph·∫£n th√¢n: T√¨m "sich|mich|dich|eur|uns" (v√≠ d·ª•: "sich √§ndern").
                - ƒê·ªông t·ª´ k√®m gi·ªõi t·ª´: X√°c ƒë·ªãnh gi·ªõi t·ª´ (v√≠ d·ª•: "teilnehmen an").
                - Danh t·ª´: N·∫øu vi·∫øt hoa, th√™m m·∫°o t·ª´ (der|die|das, tham kh·∫£o duden.de).
                - T√≠nh t·ª´/Tr·∫°ng t·ª´/ƒê·∫°i t·ª´/Gi·ªõi t·ª´/Li√™n t·ª´/Th√°n t·ª´: D√πng d·∫°ng g·ªëc.
                - tugoc: D·∫°ng ƒë√∫ng theo lo·∫°i t·ª´ (v√≠ d·ª•: "ausmachen", "der Tisch").
                - nghia: "<Lo·∫°i t·ª´>: <Nghƒ©a 1>, <Nghƒ©a 2>, ..."

          L∆∞u √Ω:
            - X√°c ƒë·ªãnh ch√≠nh x√°c lo·∫°i t·ª´, kh√¥ng c·∫Øt x√©n "${cleanedWord}".
            - Ch·ªâ ƒë∆∞a ra nghƒ©a ri√™ng cho "${cleanedWord}", kh√¥ng bao g·ªìm nghƒ©a c·ªßa t·ª´ kh√°c trong "${sentence}".
            - ∆Øu ti√™n ng·ªØ c·∫£nh "${sentence}".
            - Tham kh·∫£o dict.cc/leo.org/duden.de.
            - Tr·∫£ v·ªÅ JSON thu·∫ßn h·ª£p l·ªá trong \`\`\`json\n...\n\`\`\`.
      `;

      async function tryTranslateWithKey(keyIndex) {
        const apiKey = apiKeys[keyIndex];
        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: translationPrompt
                }]
              }]
            })
          });

          if (!response.ok) {
            if (response.status === 429 && keyIndex < apiKeys.length - 1) {
              console.warn(`API key ${keyIndex} hit rate limit, trying next key.`);
              return tryTranslateWithKey(keyIndex + 1);
            }
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          const data = await response.json();
          const content = data.candidates[0].content.parts[0].text;
          const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
          if (!jsonMatch) {
            throw new Error('Invalid JSON response from Gemini API');
          }
          const jsonData = JSON.parse(jsonMatch[1]);

          popupContent.innerHTML = `
            <p><strong>T·ª´ g·ªëc:</strong> ${jsonData.tugoc}</p>
            <p><strong>Nghƒ©a:</strong> ${jsonData.nghia}</p>
          `;
          translationPopup.style.display = 'block';
          restorePopupPosition();
        } catch (error) {
          if (keyIndex < apiKeys.length - 1) {
            console.warn(`API key ${keyIndex} failed: ${error.message}, trying next key.`);
            return tryTranslateWithKey(keyIndex + 1);
          } else {
            popupContent.innerHTML = `<p>L·ªói d·ªãch "${cleanedWord}": ${error.message}</p>`;
            translationPopup.style.display = 'block';
            restorePopupPosition();
            console.error('All API keys failed:', error);
          }
        }
      }

      if (apiKeys.length === 0 || apiKeys[0] === 'YOUR_API_KEY_1') {
        popupContent.innerHTML = '<p>Ch∆∞a cung c·∫•p API key h·ª£p l·ªá. Vui l√≤ng th√™m key Gemini v√†o m√£.</p>';
        translationPopup.style.display = 'block';
        restorePopupPosition();
        console.error('No valid API keys provided.');
        return;
      }

      tryTranslateWithKey(currentApiKeyIndex);
    }

    // Initialize
    loadFromLocalStorage();
  </script>
</body>
</html>